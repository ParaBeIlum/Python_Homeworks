# 1. Подсчитать, сколько было выделено памяти под переменные в ранее разработанных программах в рамках первых трех
# уроков. Проанализировать результат и определить программы с наиболее эффективным использованием памяти. Примечание:
# По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
# a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
# b. написать 3 варианта кода (один у вас уже есть); проанализировать 3 варианта и выбрать оптимальный;
# c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде комментариев в файл с
# кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
# d. написать общий вывод: какой из трёх вариантов лучше и почему.
#
# less_3_task_4:
# Определить, какое число в массиве встречается чаще всего.

from myfuncs import memory_counter
import random

size = 9999
array = [random.randint(0, 9999) for _ in range(size)]
array_set = set(array)
most_frq = None
max_frq = 0

for item in array_set:
    frq = array.count(item)
    if frq > max_frq:
        most_frq = item
        max_frq = frq

print(f'Число {most_frq} встречается {max_frq} раз(а)')

res = 0
lst = list(locals().values())
ids = set()
for i in lst:
    res += memory_counter(i, ids)
print('*' * 40)
print(f'Размер памяти, занимаемый переменными = {res} байт')


# print(sys.version, sys.platform)
# 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 23:11:46) [MSC v.1916 64 bit (AMD64)] win32
#
# В данном варианте решения не учитывается случай одинакового количества повторений, этот вариант выглядит коротко
# и понятно, но использование метода count вызывает дополнительные проходы массива, требует лишних затрат памяти
# При входных данных:
# size = 9999
# array = [random.randint(0, 9999) for _ in range(size)]
#
# Примерный размер памяти, занимаемый переменными = 890125 байт
#
# Вывод: считаю 1-ый вариант наиболее удачным, т.к. он учитывает случай, при котором несколько чисел имеют одинаковую
# частоту повторений, при этом использует умеренное количество памяти и может работать с объемными входными данными.
